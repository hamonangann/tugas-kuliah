# -*- coding: utf-8 -*-
"""TP05.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r6n89urqf7hrHwDLY-1oGFzdBFBRu1-3
"""

def MatrixChainOrder(p):
    n = len(p) - 1
    m = [[-1 for i in range(n)] for j in range(n)]
    s = [[-1 for i in range(n)] for j in range(n)]

    for i in range(n):
        m[i][i] = 0

    for length in range(1, n):
        for i in range(0, n-length):
            j = i+length
            for k in range(i, j):
                cost = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]
                if m[i][j] == -1 or cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    return (m, s)

def optimal_order(s, i, j):
    if i == j:
        return("A%d" % (i+1))
    else:
        return("(%s %s)" % (optimal_order(s, i, s[i][j]), optimal_order(s, s[i][j]+1, j)))

def print_optimal_order(s):
    print(optimal_order(s, 0, len(s)-1))

def solve(input):
  m, s = MatrixChainOrder(p)

  for i in m:
      print(i)
  print()

  for i in s:
      print(i)
  print()

  print_optimal_order(s)

INPUT_1 =\
"""\
6
(30,35) (35,15) (15,5) (5,10) (10,20) (20,25)
EXIT
"""

print(INPUT_1)

solve(INPUT_1)